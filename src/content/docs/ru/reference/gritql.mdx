---
title: GritQL
description: Основное использование GritQL в Biome
---

GritQL - это язык запросов для выполнения структурного поиска по исходному коду.
Это означает, что такие мелочи, как пробелы или даже тип кавычек, используемых в
строках, будут игнорироваться в вашем поисковом запросе. Кроме того, он предлагает множество
функций, которые позволяют запрашивать синтаксическую структуру, такую как фрагменты, сопоставление,
вложенность и переменные.

GritQL является [открытым исходным кодом](https://github.com/getgrit/gritql/) и создан [Grit.io](https://grit.io/).

Biome использует GritQL для двух целей:

- [Плагины анализатора](/linter/plugins).
- Команда [`biome search`](/reference/cli/#biome-search), которую мы надеемся расширить
  и на наши расширения для IDE.

## Шаблоны

Запросы GritQL работают через _шаблоны_. Наиболее распространенный шаблон, который вы увидите, -
это фрагмент кода, который выглядит как обычный исходный код, заключенный в обратные кавычки:

```grit
`console.log('Привет, мир!')`
```

Этот шаблон будет соответствовать любому вызову `console.log()`, которому передается строка
`'Привет, мир!'`. Но поскольку GritQL выполняет _структурное_ сопоставление, он не
заботится о деталях форматирования. Это также соответствует:

```js
console.log (
    'Привет, мир!'
)
```

И это тоже (обратите внимание на изменение кавычек):

```js
console.log("Привет, мир!")
```

:::note
Большинство оболочек интерпретируют обратные кавычки как вызовы команд, что конфликтует с
фрагментами кода GritQL. Поэтому при использовании команды `biome search` лучше всего
заключать ваши запросы Grit в _одинарные кавычки_:

```shell
biome search '`console.log($message)`' # найти все вызовы `console.log`
```
:::

## Переменные

Запросы GritQL также могут содержать _переменные_. Следующее будет соответствовать любому вызову
`console.log()` независимо от переданного сообщения:

```grit
`console.log($message)`
```

Это также будет соответствовать любому из методов объекта `console`:

```grit
`console.$method($message)`
```

Одно и то же имя переменной может встречаться несколько раз в одном фрагменте:

```grit
`$fn && $fn()`
```

Это будет соответствовать `foo && foo()`, и даже `foo.bar && foo.bar()`, но не
`foo && bar()`.

## Условия

Вы можете добавлять условия к шаблонам, используя оператор `where`. Он
обычно используется вместе с _оператором сопоставления_, `<:`:

```grit
`console.$method($message)` where {
    $method <: `log`
}
```

Этот запрос идентичен шаблону `console.log($message)`, который мы видели ранее,
но он быстро становится более интересным, когда мы добавляем другие операторы:

```grit
`console.$method($message)` where {
    $method <: or { `log`, `info`, `warn`, `error` }
}
```

## Сопоставление нативных узлов AST

Движок GritQL в Biome построен на основе собственных парсеров. Это позволяет вам писать шаблоны, которые напрямую сопоставляются с нативными узлами абстрактного синтаксического дерева (AST) Biome, предлагая более точную альтернативу общим, совместимым с TreeSitter шаблонам.

Нативные узлы AST Biome идентифицируются по их именам в `PascalCase` (например, `JsIfStatement`), что отличает их от совместимых с TreeSitter шаблонов в `snake_case` (например, `if_statement`).

Например, вы можете сопоставить оператор `if` в JavaScript, используя любой из шаблонов:

```grit
engine biome(1.0)
language js(typescript,jsx)

or {
  // Шаблон, совместимый с TreeSitter
  if_statement(),

  // Шаблон нативного узла AST Biome
  JsIfStatement()
} as $stmt where {
  register_diagnostic(
    span=$stmt,
    message="Найден оператор if"
  )
}
```

Использование нативных узлов AST очень эффективно, когда вам нужны конкретные и производительные запросы. Например, некоторые языковые конструкции, распознаваемые Biome, могут не иметь прямого эквивалента в общих шаблонах `snake_case`. Прямое сопоставление с узлом AST гарантирует, что вы нацелены на именно ту структуру, которую вы намереваетесь.

Вы можете найти полный список доступных узлов AST для каждого языка, изучив файлы `.ungram` в каталоге [`xtask/codegen`](https://github.com/biomejs/biome/tree/main/xtask/codegen) репозитория Biome.

## Документация по языку

Для получения дополнительной информации о GritQL и его синтаксисе см. официальную
[Документацию по языку GritQL](https://docs.grit.io/language/overview).

Пожалуйста, имейте в виду, что Biome (пока) не поддерживает все функции Grit.

## Статус интеграции

Поддержка GritQL в Biome активно разрабатывается. Многое уже работает,
но все еще ожидаются ошибки, а некоторые функции все еще отсутствуют.

Для подробного обзора того, какие функции GritQL поддерживаются, а какие еще
находятся в разработке, см. проблему на GitHub:
https://github.com/biomejs/biome/issues/2582.

У нас также есть подробный RFC, который определяет направление наших усилий по созданию плагинов:
https://github.com/biomejs/biome/discussions/1762

**tl;dr**: Мы работаем над поддержкой плагинов, которые могут быть как чисто GritQL
плагинами, так и плагинами JS/TS, которые используют GritQL для выбора кода, с которым они хотят работать.
Следите за обновлениями!